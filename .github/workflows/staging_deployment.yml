name: Staging Deployment

on:
  push:
    branches:
      - develop
      - staging
  pull_request:
    branches:
      - main
    types: [closed]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: 'false'
        type: boolean
      skip_tests:
        description: 'Skip running tests before deployment'
        required: false
        default: 'false'
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  STAGING_ENV: staging

jobs:
  quality-gates:
    name: Quality Gates
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.skip_tests != 'true' }}
    outputs:
      quality-passed: ${{ steps.quality-check.outputs.passed }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements_integration.txt
    
    - name: Run unit tests
      run: |
        python -m pytest tests/ -v --cov=agent_forge --cov-report=xml
    
    - name: Run integration tests
      run: |
        python test_integration_complete.py
    
    - name: Security scan
      run: |
        pip install bandit safety
        bandit -r agent_forge/ -f json -o security_report.json || true
        safety check --json --output safety_report.json || true
    
    - name: Code quality check
      run: |
        pip install flake8 black isort
        flake8 agent_forge/ --max-line-length=88 --extend-ignore=E203,W503
        black --check agent_forge/
        isort --check-only agent_forge/
    
    - name: Quality gate decision
      id: quality-check
      run: |
        # Check test results, coverage, security
        TESTS_PASSED=true
        COVERAGE_OK=true
        SECURITY_OK=true
        
        # Parse coverage report
        if [ -f coverage.xml ]; then
          COVERAGE=$(python -c "import xml.etree.ElementTree as ET; tree = ET.parse('coverage.xml'); print(tree.getroot().attrib['line-rate'])")
          if (( $(echo "$COVERAGE < 0.8" | bc -l) )); then
            COVERAGE_OK=false
            echo "Coverage too low: $COVERAGE"
          fi
        fi
        
        # Check for high/critical security issues
        if [ -f security_report.json ]; then
          HIGH_ISSUES=$(jq '.results | map(select(.issue_severity == "HIGH" or .issue_severity == "CRITICAL")) | length' security_report.json)
          if [ "$HIGH_ISSUES" -gt 0 ]; then
            SECURITY_OK=false
            echo "High/Critical security issues found: $HIGH_ISSUES"
          fi
        fi
        
        # Overall decision
        if [ "$TESTS_PASSED" = "true" ] && [ "$COVERAGE_OK" = "true" ] && [ "$SECURITY_OK" = "true" ]; then
          echo "passed=true" >> $GITHUB_OUTPUT
          echo "âœ… Quality gates passed"
        else
          echo "passed=false" >> $GITHUB_OUTPUT
          echo "âŒ Quality gates failed"
          if [ "${{ github.event.inputs.force_deploy }}" != "true" ]; then
            exit 1
          fi
        fi
    
    - name: Upload test reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-reports
        path: |
          coverage.xml
          security_report.json
          safety_report.json

  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [quality-gates]
    if: always() && (needs.quality-gates.outputs.quality-passed == 'true' || github.event.inputs.force_deploy == 'true' || github.event.inputs.skip_tests == 'true')
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=raw,value=staging
          type=sha,prefix={{branch}}-
    
    - name: Create Dockerfile for staging
      run: |
        cat > Dockerfile.staging << 'EOF'
        FROM python:3.11-slim
        
        WORKDIR /app
        
        # Install system dependencies
        RUN apt-get update && apt-get install -y \
            curl \
            build-essential \
            && rm -rf /var/lib/apt/lists/*
        
        # Copy requirements and install Python dependencies
        COPY requirements*.txt ./
        RUN pip install --no-cache-dir -r requirements.txt
        
        # Copy application code
        COPY . .
        
        # Create necessary directories
        RUN mkdir -p logs data models uploads
        
        # Create non-root user
        RUN useradd -m -u 1000 appuser && chown -R appuser:appuser /app
        USER appuser
        
        # Health check
        HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
            CMD curl -f http://localhost:8000/health || exit 1
        
        EXPOSE 8000
        CMD ["python", "run_api_server.py"]
        EOF
    
    - name: Build and push
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        file: Dockerfile.staging
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64,linux/arm64

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-push]
    environment:
      name: staging
      url: http://staging.agent-forge.local
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup deployment environment
      run: |
        # Install required tools
        sudo apt-get update
        sudo apt-get install -y jq curl
        
        # Setup kubectl if available
        if command -v kubectl &> /dev/null; then
          echo "kubectl is available"
        else
          echo "kubectl not available, will use Docker Compose"
        fi
    
    - name: Configure staging environment
      run: |
        cd config/staging
        
        # Create environment file from template
        cp staging_env.template .env
        
        # Update image reference
        sed -i "s|agent-forge:staging|${{ needs.build-and-push.outputs.image-tag }}|g" staging_docker-compose.yml
        
        # Set secrets (in real deployment, these would come from GitHub Secrets)
        echo "DATABASE_URL=postgresql://postgres:staging_password@postgres:5432/agent_forge_staging" >> .env
        echo "REDIS_URL=redis://redis:6379/0" >> .env
        echo "SECRET_KEY=${{ secrets.STAGING_SECRET_KEY || 'staging-secret-key-default' }}" >> .env
        echo "GRAFANA_PASSWORD=${{ secrets.GRAFANA_PASSWORD || 'admin' }}" >> .env
    
    - name: Deploy services
      run: |
        cd config/staging
        
        # Check if this is a Kubernetes environment
        if kubectl cluster-info &> /dev/null; then
          echo "Deploying to Kubernetes..."
          
          # Apply Kubernetes manifests
          kubectl apply -f staging_deployment.yml
          
          # Wait for deployment to be ready
          kubectl wait --for=condition=available --timeout=300s deployment/agent-forge-api -n agent-forge-staging
          kubectl wait --for=condition=available --timeout=300s deployment/agent-forge-websocket -n agent-forge-staging
          kubectl wait --for=condition=available --timeout=300s deployment/agent-forge-swarm -n agent-forge-staging
          
        else
          echo "Deploying with Docker Compose..."
          
          # Deploy using Docker Compose
          docker-compose -f staging_docker-compose.yml down || true
          docker-compose -f staging_docker-compose.yml up -d
          
          # Wait for services to be healthy
          echo "Waiting for services to be healthy..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health && \
               curl -f http://localhost:8001/health && \
               curl -f http://localhost:8002/health; then
              echo "All services are healthy"
              break
            fi
            echo "Attempt $i/30: Services not ready yet, waiting..."
            sleep 10
          done
        fi
    
    - name: Run database migrations
      run: |
        cd config/staging
        
        # Wait for database to be ready
        for i in {1..20}; do
          if docker-compose -f staging_docker-compose.yml exec -T postgres pg_isready -U postgres; then
            echo "Database is ready"
            break
          fi
          echo "Waiting for database... ($i/20)"
          sleep 5
        done
        
        # Run migrations if migration files exist
        if [ -d "../../migrations" ]; then
          echo "Running database migrations..."
          docker-compose -f staging_docker-compose.yml exec -T postgres \
            psql -U postgres -d agent_forge_staging -f /app/migrations/001_initial.sql || true
        fi
    
    - name: Verify deployment
      run: |
        echo "Verifying staging deployment..."
        
        # Basic health checks
        curl -f http://localhost:8000/health
        curl -f http://localhost:8001/health
        curl -f http://localhost:8002/health
        
        # Check service endpoints
        curl -f http://localhost:9090/api/v1/status/config  # Prometheus
        curl -f http://localhost:3000/api/health            # Grafana
        
        echo "âœ… Staging deployment verified successfully"
    
    - name: Run staging validation
      run: |
        # Make validation script executable
        chmod +x scripts/staging/validate_staging.sh
        
        # Run validation
        ./scripts/staging/validate_staging.sh
    
    - name: Generate deployment report
      run: |
        cat > staging_deployment_report.json << EOF
        {
          "deployment": {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "staging",
            "branch": "${{ github.ref_name }}",
            "commit": "${{ github.sha }}",
            "image": "${{ needs.build-and-push.outputs.image-tag }}",
            "actor": "${{ github.actor }}",
            "workflow_run": "${{ github.run_id }}"
          },
          "quality_gates": {
            "tests_run": ${{ github.event.inputs.skip_tests != 'true' }},
            "quality_passed": ${{ needs.quality-gates.outputs.quality-passed || 'null' }},
            "force_deployed": ${{ github.event.inputs.force_deploy == 'true' }}
          },
          "services": {
            "api": {"status": "deployed", "url": "http://localhost:8000"},
            "websocket": {"status": "deployed", "url": "http://localhost:8001"},
            "swarm": {"status": "deployed", "url": "http://localhost:8002"},
            "prometheus": {"status": "deployed", "url": "http://localhost:9090"},
            "grafana": {"status": "deployed", "url": "http://localhost:3000"}
          },
          "validation": {
            "health_checks_passed": true,
            "deployment_verified": true,
            "ready_for_testing": true
          }
        }
        EOF
    
    - name: Upload deployment artifacts
      uses: actions/upload-artifact@v3
      with:
        name: staging-deployment-artifacts
        path: |
          staging_deployment_report.json
          staging_validation_report_*.json
          logs/
    
    - name: Notify deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "âœ… Staging deployment completed successfully!"
          echo "ðŸ”— Services available at:"
          echo "   - API: http://localhost:8000"
          echo "   - WebSocket: http://localhost:8001"
          echo "   - Swarm: http://localhost:8002"
          echo "   - Prometheus: http://localhost:9090"
          echo "   - Grafana: http://localhost:3000"
        else
          echo "âŒ Staging deployment failed!"
          echo "Check the logs for more details."
        fi

  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Start monitoring
      run: |
        # Start monitoring in background
        chmod +x scripts/staging/monitor_staging.sh
        nohup ./scripts/staging/monitor_staging.sh --interval 60 > monitoring.log 2>&1 &
        echo "Monitoring started in background"
    
    - name: Run smoke tests
      run: |
        # Basic smoke tests
        echo "Running smoke tests..."
        
        # Test API endpoints
        curl -f http://localhost:8000/health
        curl -f http://localhost:8000/docs
        
        # Test metrics collection
        curl -f http://localhost:8000/metrics
        
        echo "âœ… Smoke tests passed"
    
    - name: Update deployment status
      run: |
        echo "Staging environment is ready for testing!"
        echo "Deployment completed at: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
        echo "Services are monitored and operational."

  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: always() && needs.deploy-staging.result == 'failure'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Rollback staging deployment
      run: |
        echo "Deployment failed, initiating rollback..."
        
        # Make rollback script executable
        chmod +x scripts/staging/rollback_staging.sh
        
        # Execute rollback
        ./scripts/staging/rollback_staging.sh
        
        echo "Rollback completed"
    
    - name: Upload failure logs
      uses: actions/upload-artifact@v3
      with:
        name: failure-logs
        path: |
          logs/
          staging_rollback_report_*.json